<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org"
                xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
    <body>
        <aside class="sidebar" th:fragment="sidebarFragment(menuItems)"
            th:data-subscribe-url="@{/notifications/subscribe}"
            th:data-read-url="@{/notifications/read}">
            <a th:href="@{/}" class="logo brandFont">SCIT Hub</a>

            <a th:href="@{/mypage/info}" class="profile-link">
                <section class="profile" aria-label="프로필">
                    <img
                    th:if="${currentUser != null and !#strings.isEmpty(currentUser.avatarUrl)}"
                    th:src="@{/images/avatar/{f}(f=${currentUser.avatarUrl})}"
                    alt="프로필 이미지" />

                    <img
                    th:unless="${currentUser != null and !#strings.isEmpty(currentUser.avatarUrl)}"
                    th:src="@{/images/chiikawaPuzzle.png}"
                    alt="프로필 이미지" />
                    <div>
                        <h3 class="name"
                            th:text="${currentUser != null ? currentUser.name : ''}">
                        </h3>
                        <p class="handle"
                        th:text="${currentUser != null ? '@' + currentUser.userName : ''}">
                        </p>
                    </div>
                </section>
            </a>

            <nav class="menu" aria-label="메뉴">
                <div>
                    <a th:each="menu : ${menuItems}"
                        th:href="${ctx + menu.url}"
                        th:text="${menu.name}"
                        th:classappend="${#strings.startsWith(activeUri, ctx + menu.url)} ? 'active' : ''">
                    </a>
                </div>

                <div class="menu-bottom">
                    <a th:href="@{#}" id="notification-bell" title="通知">
                        <i class="fa-solid fa-bell"></i>
                        <span>通知</span>
                        <span class="notification-badge" th:if="${unreadCount != null and unreadCount > 0}"
                            th:text="${unreadCount > 99 ? '99+' : unreadCount}"></span>
                    </a>
                    <a th:href="@{/member/logout}"><i class="fa-solid fa-right-from-bracket"></i>ログアウト</a>
                </div>
            </nav>

            <div class="bottom">
                <div class="study-card"
                    role="status"
                    aria-label="학습 현황"
                    data-start="2025-03-31"
                    data-end="2025-11-21">
                    <div class="study-head">
                        <span class="title">学習現況</span>
                        <span class="subtitle">SCIT 課程</span>
                    </div>
                    <div class="study-bottom">
                        <span class="big-percent">0%</span>

                    <!-- ■■■ 도넛: SVG 벡터(클리핑 방지) ■■■ -->
                        <div class="ring" style="--progress:0" aria-hidden="true">
                            <svg class="ringSvg" viewBox="0 0 48 48">
                                <!-- 트랙(비진행 구간) -->
                                <circle class="ringTrack" cx="24" cy="24" r="21" pathLength="100"></circle>
                                <!-- 진행(한 가지 색상) -->
                                <circle class="ringValue" cx="24" cy="24" r="21" pathLength="100"></circle>
                            </svg>
                        <!-- <span class="ringLabel">0%</span> -->
                        </div>
                    <!-- ■■■ /도넛 ■■■ -->


                    </div>
                </div>
            </div>

            <script th:inline="javascript">
            /*<![CDATA[*/
                const ctx = /*[[${ctx}]]*/ '';
                /** 날짜 문자열(YYYY-MM-DD)을 로컬타임 Date로 변환
                * @param {string} ymd - 'YYYY-MM-DD' 형식
                * @returns {Date} - 로컬 시간대 기준 Date
                */
                function parseDateLocal(ymd) {
                    /** 예외 처리: 값 없음 */
                    if (!ymd || typeof ymd !== 'string') return null;
                    const [y, m, d] = ymd.split('-').map(Number);
                    /** JS Date: month는 0부터 시작 */
                    return new Date(y, (m || 1) - 1, d || 1, 0, 0, 0, 0);
                }

                /** 진행도 퍼센트 계산 (0~100 사이로 클램프)
                * @param {Date} startDate - 시작일(로컬)
                * @param {Date} endDate - 종료일(로컬)
                * @param {Date} nowDate - 기준일(기본값=오늘)
                * @returns {number} - 퍼센트 (정수)
                */
                function calcProgressPercent(startDate, endDate, nowDate = new Date()) {
                    /** 잘못된 입력 방어 */
                    if (!(startDate instanceof Date) || isNaN(startDate)) return 0;
                    if (!(endDate instanceof Date) || isNaN(endDate)) return 0;

                    /** 구간 길이(ms) */
                    const total = endDate - startDate;
                    if (total <= 0) return 100; // 시작 ≥ 종료인 경우 완료로 간주

                    /** 진행 경과(ms) */
                    const elapsed = Math.min(Math.max(nowDate - startDate, 0), total);
                    const ratio = elapsed / total;
                    /** 소수점 반올림 */
                    return Math.round(ratio * 100);
                }

                /** DOM의 study-card에서 data-start/end를 읽어 UI 갱신
                * @param {HTMLElement} cardEl - .study-card 요소
                * @returns {void}
                */
                function updateStudyProgress(cardEl) {
                    if (!cardEl) return;

                    const startStr = cardEl.getAttribute('data-start');
                    const endStr   = cardEl.getAttribute('data-end');

                    const start = parseDateLocal(startStr);
                    const end   = parseDateLocal(endStr);

                    let percent = calcProgressPercent(start, end);
                    /** 0~100 보정 */
                    percent = Math.min(100, Math.max(0, percent));

                    /** 텍스트, 도넛 변수 반영 */
                    const percentTextEl = cardEl.querySelector('.big-percent');
                    const ringEl        = cardEl.querySelector('.ring');

                    if (percentTextEl) percentTextEl.textContent = `${percent}%`;
                    if (ringEl) ringEl.style.setProperty('--progress', String(percent));
                }

                /** 페이지 로드 시 1회 계산 */
                document.addEventListener('DOMContentLoaded', function onReady() {
                    /** 사이드바가 여러 개일 수 있으니 모두 처리 */
                    const cards = document.querySelectorAll('.sidebar .study-card[data-start][data-end]');
                    cards.forEach(updateStudyProgress);

                    // --- 알림 기능 초기화 ---
                    initNotifications();
                });

                // --- 알림 관련 로직 ---
                function initNotifications() {
                    const bell = document.getElementById('notification-bell');
                    const panel = document.getElementById('notifications-panel');
                    const closeBtn = document.getElementById('notification-close-btn');

                    // UI 요소가 없으면 실행 중지
                    if (!bell || !panel || !closeBtn) return;

                    // 1. 벨 클릭 시 body에 클래스를 추가/제거하여 패널 열기/닫기
                    bell.addEventListener('click', function(e) {
                        e.preventDefault();
                        document.body.classList.toggle('is-notification-open');
                    });

                    // 2. 닫기 버튼 클릭 시 패널 닫기
                    closeBtn.addEventListener('click', function() {
                        document.body.classList.remove('is-notification-open');
                    });

                    // 3. SSE 연결
                    // 현재 사용자가 로그인한 경우에만 SSE 연결 (Thymeleaf가 null을 전달)
                    const currentUserId = /*[[${currentUser?.userId}]]*/ null;
                    if (currentUserId) {
                        // HTML에 심어둔 정확한 구독 URL 읽기
                        const subscribeUrl = document.querySelector('[data-subscribe-url]').dataset.subscribeUrl;

                        // 읽어온 URL로 EventSource 생성
                        const eventSource = new EventSource(subscribeUrl);

                        // 'newNotification'이라는 이름의 이벤트를 수신할 리스너
                        eventSource.addEventListener('newNotification', function(event) {
                            const notification = JSON.parse(event.data);

                            // 새 알림을 목록 맨 위에 추가
                            addNotificationToList(notification);

                            // 읽지 않은 알림 개수 뱃지 업데이트
                            updateUnreadCount(1);
                        });

                        eventSource.onerror = function(error) {
                            console.error("SSE 연결 오류:", error);
                            eventSource.close();
                        };
                    }

                    // 4. 알림 링크 클릭 이벤트 리스너 추가
                    const list = document.getElementById('notification-list');
                    list.addEventListener('click', function(event) {
                        // 클릭된 요소가 .notification-link 클래스를 가진 a 태그인지 확인
                        const link = event.target.closest('.notification-link');
                        if (link) {
                            // a 태그의 기본 동작(페이지 즉시 이동)을 막음
                            event.preventDefault();

                            const notificationId = link.dataset.notificationId;
                            const targetUrl = link.href;

                            const baseReadUrl = document.querySelector('[data-read-url]').dataset.readUrl;

                            // fetch API를 사용해 서버에 '읽음' 처리 요청
                            fetch(`${baseReadUrl}/${notificationId}`, {
                                method: 'POST'
                            }).then(response => {
                                // 서버 응답이 성공적이지 않으면 에러 로그 출력
                                if (!response.ok) {
                                    return response.text().then(text => { throw new Error(text || '서버 응답 오류') });
                                }
                            return response;
                            })
                            .then(response => {   // 응답이 성공적일 때만 처리
                                if (response.ok) {
                                    console.log(`알림 ${notificationId} 읽음 처리 완료`);
                                    // UI 즉시 업데이트: 'is-unread' 클래스 제거
                                    const listItem = document.querySelector(`li[data-notification-id='${notificationId}']`);
                                    if (listItem) {
                                        listItem.classList.remove('is-unread');
                                    }
                                    // 뱃지 숫자 1 감소
                                    updateUnreadCount(-1);
                                }
                            }).catch(error => {
                                console.error("'읽음' 처리 중 에러:", error);
                                alert("알림을 읽음 처리하는 중에 오류가 발생했습니다. 페이지를 새로고침한 후 다시 시도해 주세요.");
                            }).finally(() => {
                                // 성공하든 실패하든, 최종적으로 원래 목적지로 페이지 이동
                                window.location.href = targetUrl;
                            });
                        }
                    });
                }

                // 새 알림을 목록에 동적으로 추가하는 함수
                function addNotificationToList(noti) {
                    const list = document.getElementById('notification-list');
                    const newLi = document.createElement('li');
                    newLi.className = 'is-unread'; // 새로 온 알림은 항상 '읽지 않음'
                    newLi.dataset.notificationId = noti.notificationId;

                    // 서버에서 받은 시간으로 "time ago" 텍스트 생성 (TimeUtil 로직을 JS로 구현)
                    const timeAgoText = formatTimeAgo(noti.createdAt);
                    const fullTimeText = new Date(noti.createdAt).toLocaleString();

                    const fullTargetUrl = ctx + noti.targetUrl;

                    newLi.innerHTML = `
                        <a href="${fullTargetUrl}" class="notification-link" data-notification-id="${noti.notificationId}">
                            <strong class="noti-title">${noti.title}</strong>
                            <p class="noti-content">${noti.content}</p>
                            <span class="noti-time" title="${fullTimeText}">${timeAgoText}</span>
                        </a>
                    `;
                    list.prepend(newLi); // 새 알림을 맨 위에 추가
                }

                // 읽지 않은 알림 개수 뱃지를 업데이트하는 함수
                function updateUnreadCount(change) {
                    let badge = document.querySelector('.notification-badge');

                    if (!badge && change > 0) { // 뱃지가 없었는데 새로 생겼다면
                        const bell = document.getElementById('notification-bell');
                        badge = document.createElement('span');
                        badge.className = 'notification-badge';
                        badge.textContent = '0';
                        bell.appendChild(badge);
                    }

                    if (badge) {
                        let currentCount = parseInt(badge.textContent.replace('+', '')) || 0;
                        let newCount = currentCount + change;

                        if (newCount > 99) {
                            badge.textContent = '99+';
                        } else {
                            badge.textContent = newCount;
                        }

                        if (newCount <= 0) {
                            badge.style.display = 'none';
                        } else {
                            badge.style.display = 'inline-flex';
                        }
                    }
                }

                // 'N분 전'과 같이 상대 시간을 계산하는 함수
                function formatTimeAgo(dateString) {
                    const now = new Date();
                    const past = new Date(dateString);
                    const seconds = Math.floor((now - past) / 1000);

                    let interval = seconds / 31536000;
                    if (interval > 1) return Math.floor(interval) + "年前";
                    interval = seconds / 2592000;
                    if (interval > 1) return Math.floor(interval) + "ヶ月前";
                    interval = seconds / 86400;
                    if (interval > 1) return Math.floor(interval) + "日前";
                    interval = seconds / 3600;
                    if (interval > 1) return Math.floor(interval) + "時間前";
                    interval = seconds / 60;
                    if (interval > 1) return Math.floor(interval) + "分前";
                    return "たった今";
                }
            /*]]>*/
            </script>
        </aside>
    </body>
</html>
